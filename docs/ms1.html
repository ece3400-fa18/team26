<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>ECE 3400 Team 26</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Kaushan+Script' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700' rel='stylesheet' type='text/css'>

    <!-- Custom styles for this template -->
    <link href="css/agency.css" rel="stylesheet">

  </head>

  <body id="page-top">

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top" id="mainNav">
      <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="index.html">Home</a>
        
      </div>
    </nav>

    <!-- Header -->
     <div class="pagehead">
      <div class="container">
        <h2>  </h2>
      </div>
    </div> 

    <div class="container">
        <div class="row">
          <div class="col-lg-8 mx-auto">
            <div class="lab-page">
              <!-- Project Details Go Here -->
              <h2 class="text-uppercase text-left">Milestone 1: Basic Movement</h2>
              <p class="item-intro text-muted"> The goal of this lab is to make the robot to follow the line and traverse in a figure 8. The robot is controlled using the reading from line sensor in order to make decisions regarding following lines and turning. We first created a simpler iteration that followed straight lines, and after a successful implementation we modified the code so the robot could follow turns, and ultimately traverse the figure 8.</p>  

              <img class="img-fluid d-block mx-auto" width="600" height="100" src="./img/ms1/robot_side.jpg" alt="">
              
              <h3> Line Sensors </h3>
              <p>There are four line sensors attached to the front of the robot. Two line sensors are in the middle and two line sensors are on the outer side. For this part, we only need the middle ones for controlling the robot. The middle line sensors are on top of a white tape for following the straight line and making corrections. If either of them detects a value above the white tape threshold value, it means that the the robot is leaning towards one side. In this situation, the robot will make a slight correction by speeding up one of the servo by how much the robot is out of bound. The magnitude of how much the robot is out of bound is determined by the difference between the right middle sensor and the left middle sensor.  </p>             
              <!--<img class="img-fluid d-block mx-auto" width="400" height="80" src="./img/lab1/part 1.png" alt="">-->
              <iframe width="560" height="315" src="https://www.youtube.com/embed/UUIaZkpNXYs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
              <br>
              <code>
                void move(){<br>
                  &emsp; // Read analog values from two center sensors<br>
                  &emsp; right_pid_val = analogRead(right_pid); // signal from center right sensor<br>
                  &emsp; left_pid_val = analogRead(left_pid);   // signal from center left sensor<br>
                  &emsp; error = left_pid_val - right_pid_val; // Positive position to right of line<br>
                  <br>
                  &emsp; // Correct robot's driving direction according to position error<br>
                  &emsp; if (abs(error) <= ERROR_RANGE){<br>
                    &emsp; &emsp; left_servo.write(SERVO_L_FORWARD_MAX);<br>
                    &emsp; &emsp; right_servo.write(SERVO_R_FORWARD_MAX);<br>
                  &emsp; }<br>
                  <br>
                  &emsp; // Robot is too right of line<br>
                  &emsp; else if (error > ERROR_RANGE) {<br>
                    &emsp; &emsp; // Adjust left<br>
                    &emsp; &emsp; error_magnitude = abs(error)/(float)ERROR_RANGE;<br>
                    &emsp; &emsp; left_servo.write(SERVO_L_FORWARD_MAX - error_magnitude*SERVO_L_INCR_FORWARD);<br>
                    &emsp; &emsp; right_servo.write(SERVO_R_FORWARD_MAX + error_magnitude*SERVO_R_INCR_FORWARD);<br>
                  &emsp; }<br>
                  <br>
                  &emsp; // Robot is too left of line<br>
                  &emsp; else if (error < -(ERROR_RANGE)) {<br>
                    &emsp; &emsp; // Adjust right<br>
                    &emsp; &emsp; error_magnitude = abs(error)/(float)ERROR_RANGE;<br>
                    &emsp; &emsp; left_servo.write(SERVO_L_FORWARD_MAX + error_magnitude*SERVO_L_INCR_FORWARD);<br>
                    &emsp; &emsp; right_servo.write(SERVO_R_FORWARD_MAX - error_magnitude*SERVO_R_INCR_FORWARD);<br>
                  &emsp; }<br>
                  &emsp; delay(10);<br>
                }<br>
              </code>
              
              <h3> Figure 8 Traversal </h3>
              <p> The two outer sensors are used to determine which direction to turn: if either sensor detects white, then the robot accordingly executes 90 degree turn in that direction. In the case where the robot sensors a white line in both the left and right direction (as in the vertex of a T), the robot defaults to right.</p>
              <p>For the purpose of a figure eight, the robot was hard coded to go right for the first three turns and left for the second three turns. This implementation was an extension of the previous “Following Straight Lines” so the application of the inner sensors remains the same as specified above. </p>
              
              <!--<img class="img-fluid d-block mx-auto" width="400" height="80" src="./img/lab1/part 2.png" alt="">-->
              <iframe width="560" height="315" src="https://www.youtube.com/embed/5_2vB0YuRrI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
              
              <p> Declaring variables in the beginning  </p><br>
              <p> We first declare several variables. left_servo and right_servo indicate the servos on the left and right of the robot that turn the wheels. We then define several parameters that help us control the servo. When SERVO_BREAK is written to either servo, it will make the servo stop turning. The following definitions are called to make the servos spin in the directions that make the robot either go forward or backward.<br>
              We then define the thresholds for each sensor to determine when it has crossed a line. In this case, we are specifically looking for a white line, so the robot can traverse the grid. The middle two sensors have a threshold of 200, indicating light colors, like white, and the outside two sensors have a threshold of 600, indicating the darker grey background. <br>
              We have also defined the pins for each servo and each sensor as constants.
              </p>
              
              <code>
              Servo left_servo;<br>
              Servo right_servo;<br>
              <br>
              #define SERVO_BRAKE          90<br>
              #define SERVO_L_FORWARD_MAX  100.0<br>
              #define SERVO_R_FORWARD_MAX  80.0<br>
              #define SERVO_L_INCR_FORWARD -2.0<br>
              #define SERVO_R_INCR_FORWARD 2.0<br>
              <br>
              // Thresholds for each sensor to determine when over a line<br>
              #define RIGHT_PID_THRESH     200<br>
              #define LEFT_PID_THRESH      200<br>
              #define RIGHT_TURN_THRESH    600<br>
              #define LEFT_TURN_THRESH     600<br>
              <br>
              #define ERROR_RANGE          100<br>
              <br>
              //pins<br>
              const int LW = 9; // Servo1<br>
              const int RW = 10; // Servo2<br>
              const int right_turn = A3;<br>
              const int right_pid = A2;<br>
              const int left_pid = A1;<br>
              const int left_turn = A0;<br>
              <br>
              // Control variables for line following<br>
              float error           = 0;<br>
              float error_magnitude = 0;<br>
              int   counter         = 0;<br>
              <br>
              // Line sensor values<br>
              int right_pid_val     = 0;<br>
              int left_pid_val      = 0;<br>
              int right_turn_val    = 0;<br>
              int left_turn_val     = 0;<br>
              <br>
              // Servo turn values<br>
              float servo_turn_value[]   = {SERVO_R_FORWARD_MAX, 0 ,SERVO_L_FORWARD_MAX, SERVO_L_FORWARD_MAX};<br>
              int   servo_turn_delays [] = {300, 0, 300, 900};<br>
              </code>
              <br>
              
              
              <p> The main move method  </p> <br>
              <p> The main move method takes in one parameter, direction of type int. If the robot is requested to move (indicated by direction not being equal to 1), the servo will being turning until the sensors read that the robot is off of the current line, and will continue turning the robot until it reaches its destination line. Similarly to the code above for the robot to follow a straight line, we also include error-correction, so the robot is able to correct itself when it starts to veer away from the line.
              </p>
              
              <code>
              void move(int direction){<br>
                &emsp; // Turn if requested<br>
                &emsp; if (direction != 1){<br>
                  &emsp; &emsp; // Start turning until off the current line<br>
                  <!--left_servo.write(servo_turn_value[direction]);<br>-->
                  <!--right_servo.write(servo_turn_value[direction]);<br>-->
                  <!--delay(servo_turn_delays[direction]);<br>-->
                  <!--<br>-->
                  &emsp; &emsp; // Read values from center line sensors<br>
                  <!--right_pid_val = analogRead(right_pid);<br>-->
                  <!--left_pid_val = analogRead(left_pid);<br>-->
                  <br>
                  &emsp; &emsp; // While center sensors are not over another line, continue turning<br>
                  &emsp; &emsp; while((right_pid_val> RIGHT_PID_THRESH) && (left_pid_val> LEFT_PID_THRESH)){<br>
                    <!--right_pid_val = analogRead(right_pid);<br>-->
                    <!--left_pid_val = analogRead(left_pid); <br>-->
                  &emsp; &emsp; }<br>
                &emsp; } // done turning<br>
                <br>
                &emsp; // Reset intersection variables  <br>
                  &emsp; &emsp; right_turn_val = 0;<br>
                  &emsp; &emsp; left_turn_val = 0;<br>
                  &emsp; &emsp; counter = 50;<br>
                <br>
                <br>
                &emsp; // After turn is complete, drive forward to the next intersection, making corrections as necessary<br>
                &emsp; // while-loop contains all line-following code<br>
                &emsp; while(right_turn_val < RIGHT_TURN_THRESH || left_turn_val < LEFT_TURN_THRESH){<br>
                  &emsp; &emsp; // Wait 50 while-loops for robot to be clear of starting intersection<br>
                  &emsp; &emsp; // Don't start searching for an intersection until the intersection sensors are clear of black line<br>
                  &emsp; &emsp; if (counter > 0){<br>
                    &emsp; &emsp; &emsp; right_turn_val =3000; //set so that while loop continues<br>
                    &emsp; &emsp; &emsp; left_turn_val = 3000;  //set so that while loop continues <br>
                    &emsp; &emsp; &emsp; counter = counter - 1;<br>
                  &emsp; &emsp; }<br>
                  &emsp; &emsp; else {<br>
                    &emsp; &emsp; &emsp; right_turn_val = analogRead(right_turn); //signal from outer right sensor<br>
                    &emsp; &emsp; &emsp; left_turn_val = analogRead(left_turn); //signal from outer left sensor <br>
                  &emsp; &emsp; }<br>
                  <br>
                  &emsp; &emsp; //following straight line<br>
                  &emsp; &emsp; // Read analog values from two center sensors<br>
                  &emsp; &emsp; right_pid_val = analogRead(right_pid); // signal from center right sensor<br>
                  &emsp; &emsp; left_pid_val = analogRead(left_pid);   // signal from center left sensor <br>
                  <br>
                  <!--// Print statements for debugging<br>-->
                  <!--  //Serial.println(right_pid_val);<br>-->
                  <!--  //Serial.println(left_pid_val);  <br>-->
                  <!--  //Serial.println();  <br>-->
                  <!--  <br>-->
                  &emsp; &emsp; error = left_pid_val - right_pid_val; // Positive position to right of line<br>
                <br>
                  &emsp; // Correct robot's driving direction according to position error<br>
                  &emsp; if (abs(error) <= ERROR_RANGE){<br>
                    &emsp; &emsp; left_servo.write(SERVO_L_FORWARD_MAX);<br>
                    &emsp; &emsp; right_servo.write(SERVO_R_FORWARD_MAX);<br>
                  &emsp; }<br>
                  <br>
                  &emsp; // Robot is too right<br>
                  &emsp; else if (error > ERROR_RANGE) {<br>
                    &emsp; &emsp; // Adjust left<br>
                    <!--error_magnitude = abs(error)/(float)ERROR_RANGE;<br>-->
                    <!--left_servo.write(SERVO_L_FORWARD_MAX - error_magnitude*SERVO_L_INCR_FORWARD);<br>-->
                    <!--right_servo.write(SERVO_R_FORWARD_MAX + error_magnitude*SERVO_R_INCR_FORWARD);<br>-->
                  &emsp; }<br>
                  &emsp; // Robot is too left of line<br>
                  &emsp; else if (error < -(ERROR_RANGE)) {<br>
                  &emsp; &emsp; // Adjust right<br>
                    <!--error_magnitude = abs(error)/(float)ERROR_RANGE;<br>-->
                    <!--left_servo.write(SERVO_L_FORWARD_MAX + error_magnitude*SERVO_L_INCR_FORWARD);<br>-->
                    <!--right_servo.write(SERVO_R_FORWARD_MAX - error_magnitude*SERVO_R_INCR_FORWARD);<br>-->
                  &emsp; }<br>
                  &emsp; delay(10);<br>
                &emsp; }<br>
                &emsp; left_servo.write(SERVO_BRAKE);<br>
                &emsp; right_servo.write(SERVO_BRAKE);<br>
              }<br>
              </code>
              
              <p> Set up the hardware and all I/Os  </p><br>
              <p> In this section, we connect the servos and the sensors to the pins defined above.</p>
              </p>
              
              <code>
              void setup() {<br>
                &emsp; // put your setup code here, to run once:<br>
                &emsp; Serial.begin(9600);<br>
                &emsp; right_servo.attach(RW);<br>
                &emsp; left_servo.attach(LW);<br>
                <br>
                &emsp; // Set up the select pins as outputs:<br>
                &emsp; pinMode(A0, INPUT);<br>
                &emsp; digitalWrite(A0, HIGH);<br>
                &emsp; pinMode(A1, INPUT);<br>
                &emsp; digitalWrite(A1, HIGH);<br>
                &emsp; pinMode(A2, INPUT);<br>
                &emsp; digitalWrite(A2, HIGH);<br>
                &emsp; pinMode(A3, INPUT);<br>
                &emsp; digitalWrite(A3, HIGH);<br>
                <br>
                &emsp; right_servo.write(SERVO_BRAKE);<br>
                &emsp; left_servo.write(SERVO_BRAKE);<br>
                <br>
                &emsp; delay(1000);<br>
              }<br>   
              </code>

              <p> Main Code to run repeatedly </p>
              <p> Due to the fact that all the set-up and helper functions are already implemented, the main loop merely calls on the subroutines to run the entire program. It assumes the behavior of running in a straight line, and then calls the turn functions when it encounters an intersection (left or right specific, nevertheless both sides implemented in the same fashion).</p>
              
              <code>
              void loop() {<br>
                &emsp; // move in figure-8<br>
                &emsp; move(2);   // forward one block<br>
                &emsp; delay(50);<br>
              }<br>
              </code>
              
              
              
              <h3> Work Distribution </h3>
              <p> The Milestone 1 Work Distribution is as follows: <br> 
                  &emsp; - On 9/7, Joyce, Nathalia, Priya, and Vini worked on in lab rebuild the robot.<br>
                  &emsp; - On 9/10, Joyce, Nathalia, and Vini worked on rebuilding the robot and started the code. <br>
                  &emsp; - On 9/10, Nathalia went to open office hours and finished rebuilding the robot.<br>
                  &emsp; - On 9/14, Joyce, Nathalia, Priya, and Vini worked on in lab to complete the milestone.<br>
                  
                  The Lab Report Work Distribution is as follows: <br>
                  &emsp; - Joyce: Introduction and code explanations<br>
                  &emsp; - Priya: Section Write Ups<br>
                  &emsp; - Nathalia: Pictures and Videos<br>
                  
                  The website work distribution is as follows: <br>
                  &emsp; - Nathalia: Website Set Up and Milestone 1<br>
              </p>
            </div>
          </div>
        </div>
      </div>

    

    <!-- Footer -->
    <footer>
      <div class="container">
        <div class="row">
          <div class="col-md-4">
            <span class="copyright">Copyright &copy; Your Website 2018</span>
          </div>
          <div class="col-md-4">
            <ul class="list-inline social-buttons">
              <li class="list-inline-item">
                <a href="#">
                  <i class="fab fa-twitter"></i>
                </a>
              </li>
              <li class="list-inline-item">
                <a href="#">
                  <i class="fab fa-facebook-f"></i>
                </a>
              </li>
              <li class="list-inline-item">
                <a href="#">
                  <i class="fab fa-linkedin-in"></i>
                </a>
              </li>
            </ul>
          </div>
          <div class="col-md-4">
            <ul class="list-inline quicklinks">
              <li class="list-inline-item">
                <a href="#">Privacy Policy</a>
              </li>
              <li class="list-inline-item">
                <a href="#">Terms of Use</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </footer>

 

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Contact form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Custom scripts for this template -->
    <script src="js/agency.min.js"></script>

  </body>

</html>
